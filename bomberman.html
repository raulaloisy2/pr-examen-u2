<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TBOI: Bomberman</title>
</head>

<canvas id="mycanvas"  width="1000" height="600"> </canvas>
<audio   id="miAudio">
       <source src="files/sounds/InnocenceGlitched.mp3" type="audio/mpeg"> </audio>






<body style="background-color: black;">
</body>




<script>
//Variables 
    //Canvas , imagenes y audio
    var canvas = document.getElementById('mycanvas'); 
    var ctx = canvas.getContext('2d');
    var musica = document.getElementById('miAudio');
    var imagenPlayer = new Image();
    imagenPlayer.src= "files/img/isaac.png";
    
    
    //Gameplay
 
    var playerX=40 , playerY=40;
    var pause = false;
    var speed = 2;
    var dir=0;
    
    
    //Clases

    class GenerarJugador {
        constructor( w, h) {
            this.w=w;
            this.h=h;
        }
    
    }

    class GenerarPared {
        constructor(x, y,rompible) {
            this.x = x;
            this.y = y;
            this.w = 40;
            this.h = 40;
            this.rompible=rompible;

            if(rompible){
                this.image = new Image();
                this.image.src = "files/img/roca.png"; // Asegúrate de que la ruta sea correcta
            }else{
                this.image = new Image();
                this.image.src = "files/img/metal.png"; // Asegúrate de que la ruta sea correcta 
            }

    
            // Agrega un evento onload para asegurarte de que la imagen se haya cargado correctamente
            this.image.onload = () => {
                // Llama a pintar después de cargar la imagen
                this.pintar(ctx);
            };
        }
    
        pintar(ctx) {
            // Verifica que la imagen se haya cargado correctamente antes de intentar dibujarla
            if (this.image.complete) {
                ctx.drawImage(this.image, this.x, this.y, 45, 45);
            }
        }
        //EVITA ATRAVESAR ELEMENTOS
        colisionConCuadro(player) {
            console.log(player.x)
            if (playerX + player.w > this.x && 
            playerX < this.x + this.w &&
            playerY + player.h > this.y &&
            playerY < this.y + this.h) {
            // Colisión detectada
            switch (dir) {
                case 87: // Tecla "W"
                    playerY += speed * 2;
                    break;
                case 83: // Tecla "S"
                    playerY -= speed * 2;
                    break;
                case 68: // Tecla "D"
                    playerX -= speed * 2;
                    break;
                case 65: // Tecla "A"
                    playerX += speed * 2;
                    break;
                default:
                    break;
            }
            dir = 0;
            return true;
        }
            return false; // No hay colisión
        }

        static pintarParedes(ctx, paredes) {
            for (let i = 0; i < paredes.length; i++) {
                paredes[i].pintar(ctx);
            }
        }
    }



    //OBJETOS DECLARADOS
    var player = new GenerarJugador(30,30);
    ctx.drawImage(imagenPlayer, 0, 0);
    let walls = []
    paredesOrilla(walls);
    paredesJuego(walls);
   // walls.push(new GenerarPared(0, 0,false));
   // walls.push(new GenerarPared(0, canvas.height-20,false));
   // walls.push(new GenerarPared(200,200,false));
    //walls.push(new GenerarPared(200,300,false));


//FUNCIONES 

//FONDO
    function drawBackground(){
        
        ctx.beginPath();
        ctx.fillStyle = "#6F5B52";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.closePath();

    }

    function paredesOrilla(walls) {
        const borderWidth = 40; // Ancho de la pared
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        // Pintar pared superior
        for (let x = 0; x < canvasWidth; x += borderWidth) {
            walls.push(new GenerarPared(x, 0));
        }
    
        // Pintar pared inferior
        for (let x = 0; x < canvasWidth; x += borderWidth) {
            walls.push(new GenerarPared(x, canvasHeight - borderWidth));
        }
    
        // Pintar pared izquierda
        for (let y = 0; y < canvasHeight; y += borderWidth) {
            walls.push(new GenerarPared(0, y));
        }
    
        // Pintar pared derecha
        for (let y = 0; y < canvasHeight; y += borderWidth) {
            walls.push(new GenerarPared(canvasWidth - borderWidth, y));
        }
    }

    function paredesJuego(walls) {
        const cuadriculaX = 14; // Número de bloques en el eje X
        const cuadriculaY = 8; // Número de filas en el eje Y
        const borderWidth = 40; // Ancho de la pared
        const canvasWidth = canvas.width - 80;
        const canvasHeight = canvas.height - 80;
        
        for (let y = 80; y < canvasHeight; y += borderWidth) {
            let rompibles = false; // Inicia con todas las columnas como rompibles en cada fila
            
            for (let x = 80; x < canvasWidth; x += borderWidth) {
                const cuadriculaXIndex = Math.floor(x / borderWidth) % cuadriculaX;
                const cuadriculaYIndex = Math.floor(y / borderWidth) % cuadriculaY;
    
                // Comprueba si estamos en una fila par o impar para alternar rompibles y no rompibles
                const enFilaPar = cuadriculaYIndex % 2 === 0;
    
                // Establece rompibles en función de la lógica deseada
                const rompible = enFilaPar ? rompibles : true;
    
                walls.push(new GenerarPared(x, y, rompible));
                
                // Alterna el valor de rompibles para la próxima columna en la misma fila
                rompibles = !rompibles;
            }
        }
    }
    
    // Para crear la disposición de bloques al estilo de Bomberman:
    paredesJuego(walls);
    
    
//VERIFICA EL ARREGLO DE WALLS SI UNO DE ELLOS TIENE UNA COLISIÓN
    function verificarColisiones() {
        for (var i = 0; i < walls.length; i++) {
            if (walls[i].colisionConCuadro(player)) {
                // Realiza alguna acción en caso de colisión
                console.log("Colisión detectada con la pared " + i);
            }
        }
    }

    function drawBackground(){
        
        ctx.beginPath();
        ctx.fillStyle = "#6F5B52";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.closePath();

    }
    //FUNCION REPINTAR
    function repaint(){
        if (!pause){

            drawBackground();
            //Dibujar PLayer
            ctx.drawImage(imagenPlayer, playerX, playerY,40,45);

            ctx.fillStyle = "Black";
           
            //Dibujar Paredes
            GenerarPared.pintarParedes(ctx, walls);
           
        }else{
            ctx.fillStyle="Black";
            ctx.font = "30px Arial";
            ctx.fillText("P A U S A ", 180 , 250);
            ctx.fillStyle="rgba(138, 196, 172,0.1)";
            ctx.fillRect(0,0,500,500);
        
        };
     
      
                
    };
    //Pintar Fondo
    drawBackground();
    //LECTURA DEL TECLADO
    document.addEventListener("keydown", (e) => {

             musica.play();
            console.log(e.keyCode);

            switch(e.keyCode){
                case 87:
                dir=e.keyCode;
                    playerY-=speed;
                    break;
                case 65:    
                dir=e.keyCode;
                    playerX-=speed;
                    break;
                case 83:
                dir=e.keyCode;
                    playerY+=speed;
                    break;
                case 68:
                dir=e.keyCode;
                    playerX+8;
                    break;
                    case 81:
                    console.log ("Pausa");
                    if(!pause){
                        pause=true;
                    }
                    else{
                        pause=false;
                    }
                    break;

                default:
                    break;
            };
    
    });

    //Verifica que el player no pueda salir de la pantalla
    function update(){
        if(pause==false){
            switch (dir) {
                case 87:  
                if (!pause){
                    playerY -= speed;
                  
                    if(playerY<-50){playerY=580}
                }
               
                    break;
    
                case 83:
                if(pause==false){
                    playerY += speed;
             
                    if(playerY>580){playerY=0}
                }
                    break;
    
                case 68:
                if(pause==false){
                    playerX += speed;
                   

                    if(playerX>1000){playerX=0}
                }
                    break;
    
                    case 65:
                    if(pause==false){
                    playerX -= speed;
        
                    if(playerX<-50){playerX=980}
                    }
                    break;

                    case 81:
                    console.log ("Pausa");
                    if(!pause){
                        pause=true;
                    }
                    else{
                        pause=false;
                    }
                    break;
    
                default:
                    break;
                }

          /*  if(x < t_x + 50  &&  x + 40 > t_x &&    y < t_y + 50 &&    y +40 > t_y){  
                
                console.log("+10 Puntos");
                coinSound.play();
                t_x= getRandomInt(460);
                t_y= getRandomInt(460);
                score+=10;
            }
            */
            }

        
            verificarColisiones();
            repaint();
            if(!pause){
                //HUD SI NO HAY PAUSA
            }
       
            window.requestAnimationFrame(update);    
    }




    //REQUEST ANIMATION
    window.requestAnimationFrame = (function () {
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 17);
            };
    }());
    window.requestAnimationFrame(update); 
</script>
</html>
